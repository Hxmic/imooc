#include "SingleList.h"#include <iostream>using namespace std;List::List(){	m_pList = new Node;	m_pList->data = 0;	m_pList->next = NULL;	m_iLength = 0;} List::~List(){	ClearList();	delete m_pList;	m_pList = NULL;}void List::ClearList(){	//清空链表并没有删除链表，所以m_pList指针的值不要变	Node *currentNode = m_pList->next;		//链表的第一个数据节点是这个，头节点是没有意义的	while(currentNode != NULL)	{		Node *temp = currentNode->next;		delete currentNode;		currentNode = temp;	}	m_pList->next = NULL;}bool List::ListEmpty(){	if(m_iLength == 0)	{		return true;	}	return false;}int List::ListLength(){	return m_iLength;}bool List::ListInsertHead(Node *pNode){	Node *headNode = new Node;	if(headNode == NULL)	{		return false;	}	headNode->data = pNode->data;	headNode->next =m_pList->next; 	m_pList->next = headNode;	m_iLength++;	return true;}bool List::ListInsertTail(Node *pNode){	Node *currentNode = m_pList;	while(currentNode->next != NULL)	{		currentNode = currentNode->next;	}	Node *tailNode = new Node;	if(tailNode == NULL)	{		return false;	}	tailNode->data = pNode->data;	tailNode->next = NULL;	currentNode->next = tailNode;	m_iLength++;	return true;}bool List::ListInsert(int i, Node *pNode)		//插到第i个下标位置{	if(i <= 0 || i > m_iLength)	{		return false;	}	Node *currentNode = m_pList;	for(int ii = 0; ii < i-1; ii++)	{		currentNode = currentNode->next;	}	Node *insertNode = new Node;	if(insertNode == NULL)	{		return false;	}	insertNode->data = pNode->data;	insertNode->next = currentNode->next;	currentNode->next = insertNode;	m_iLength++;	return true;}bool List::ListDelete(int i, Node *pNode){	if(i < 0 || i >= m_iLength)	{		return false;	}	Node *currentNode = m_pList;	Node *beforeNode = NULL;	for(int ii = 0; ii < i; ii++)	{		beforeNode = currentNode;		currentNode = currentNode->next;	}	beforeNode->next = currentNode->next;	pNode->data = currentNode->data;	delete currentNode;	currentNode = NULL;	m_iLength--;	return true;}bool List::GetElem(int i, Node *pNode){	if(i < 0 || i >= m_iLength)	{		return false;	}	Node * currentNode = m_pList;	for(int ii = 0; ii < i; ii++)	{		currentNode = currentNode->next;	}	pNode->data = currentNode->data;	return true;}int List::LocateElem(Node *pNode){	Node *currentNode = m_pList->next;	int count = 0;	while(currentNode != NULL)	{		if(currentNode->data == pNode->data)		{			return count;		}		currentNode = currentNode->next;		count++;	}	return -1;}bool List::PriorElem(Node *currentElem, Node *preElem){	Node *currentNode = m_pList->next;	Node *beforeNode = NULL;	for(int ii = 0; ii < m_iLength; ii++)	{		beforeNode = currentNode;		currentNode = currentNode->next;		if(currentNode->data == currentElem->data)		{			preElem->data = beforeNode->data;			preElem->next = beforeNode->next;			return true;		}	}	return false;}bool List::NextElem(Node *currentElem, Node *nextElem){	Node *currentNode = m_pList->next;	for(int ii = 0; ii < m_iLength-1; ii++)	{		if(currentNode->data == currentElem->data)		{			nextElem->data = currentNode->next->data;			nextElem->next = currentNode->next;			return true;		}		currentNode = currentNode->next;	}	return false;}void List::ListTraverse(){	Node *currentNode = m_pList->next;	while(currentNode != NULL)	{		currentNode->printNode();		currentNode = currentNode->next;	}}