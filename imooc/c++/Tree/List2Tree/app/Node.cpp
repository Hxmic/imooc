#include <iostream>#include "Node.h"using namespace std;Node::Node(){	nodeIndex = 0;	data = 0;	m_pParentNode = NULL;	m_pLeftNode = NULL;	m_pRightNode = NULL;}Node::~Node(){	}Node *Node::SearchNode(int nodeIndex){	if(this->nodeIndex == nodeIndex)	{		return this;	}	//二叉树遍历	Node *temp = NULL;	if(this->m_pLeftNode != NULL)	{		if(this->m_pLeftNode->nodeIndex == nodeIndex)		{			return this->m_pLeftNode;		}		else		{			temp = this->m_pLeftNode->SearchNode(nodeIndex);			if(temp != NULL)			{				return temp;			}		}		if(this->m_pRightNode->nodeIndex == nodeIndex)		{			return this->m_pRightNode;		}			else		{			temp = this->m_pRightNode->SearchNode(nodeIndex);			if(temp != NULL)			{				return temp;			}		}	}	return NULL;}void Node::DeleteNode(){	//首先删除孩子节点	if(this->m_pLeftNode != NULL)	{		this->m_pLeftNode->DeleteNode();	}	if(this->m_pRightNode != NULL)	{		this->m_pRightNode->DeleteNode();	}	//然后清空父节点指针后，自杀	if(this->m_pParentNode != NULL)	{		if(this->m_pParentNode->m_pLeftNode == this)		{			this->m_pParentNode->m_pLeftNode =NULL;		}		if(this->m_pParentNode->m_pRightNode == this)		{			this->m_pParentNode->m_pRightNode =NULL;		}	}	delete this;}void Node::PreorderTraversal(){	cout << this->nodeIndex << " --- " << this->data << endl;	if(this->m_pLeftNode != NULL)	{		this->m_pLeftNode->PreorderTraversal();	}	if(this->m_pRightNode != NULL)	{		this->m_pRightNode->PreorderTraversal();	}	}void Node::InorderTraversal(){	if(this->m_pLeftNode != NULL)	{		this->m_pLeftNode->InorderTraversal();	}	cout << this->nodeIndex << " --- " << this->data << endl;	if(this->m_pRightNode != NULL)	{		this->m_pRightNode->InorderTraversal();	}}void Node::PostorderTraversal(){	if(this->m_pLeftNode != NULL)	{		this->m_pLeftNode->PostorderTraversal();	}	if(this->m_pRightNode != NULL)	{		this->m_pRightNode->PostorderTraversal();	}	cout << this->nodeIndex << " --- " << this->data << endl;}