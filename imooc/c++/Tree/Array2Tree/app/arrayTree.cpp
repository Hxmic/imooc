#include <iostream>#include "arrayTree.h"using namespace std;arrayTree::arrayTree(int size, int *root){	m_iSize = size;	m_pTree = new int[size];	for(int i = 0; i < size; i++)	{		m_pTree[i] = 0;	}	m_pTree[0] = *root;}arrayTree::~arrayTree(){	delete [] m_pTree;	m_pTree = NULL;}//nodeIndex 数组下标int *arrayTree::SearchNode(int nodeIndex){	if(nodeIndex < 0 || nodeIndex > m_iSize-1)	{		return NULL;	}	return &m_pTree[nodeIndex];}//direction 0为左孩子 1为右孩子bool arrayTree::AddNode(int nodeIndex, int direction, int *pNode){	int iLeftIndex = nodeIndex * 2 + 1;	int iRightIndex = nodeIndex * 2 + 2;	if(nodeIndex < 0 || iRightIndex > m_iSize-1)	{		return false;	}		//判断要插入的节点是否为空	if(m_pTree[iLeftIndex] == 0 && direction == 0)	{		m_pTree[iLeftIndex] = *pNode;		return true;	}	if(m_pTree[iRightIndex] == 0 && direction == 1)	{		m_pTree[iRightIndex] = *pNode;		return true;	}		return false;}bool arrayTree::DeleteNode(int nodeIndex, int *pNode){	if(nodeIndex < 0 || nodeIndex > m_iSize-1)	{		return false;	}	*pNode = m_pTree[nodeIndex];	m_pTree[nodeIndex] = 0;	return true;}void arrayTree::TreeTraverse(){	for(int i = 0; i < m_iSize; i++)	{		cout << m_pTree[i] << ", ";	}	cout << endl;}